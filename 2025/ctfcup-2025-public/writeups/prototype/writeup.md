# Protoype service
## Базовый сценарий
Пользователь заходит на сервис, создает свой коктейль, лайкает пару других, уходит. Затем он приходит и проверяет наличие корректного секретного ингредиента в своих рецептах. Пользователю важно, чтобы превью коктейля оставалось неизменным.

### Все фичи
- Пользователь создает прототипы коктейлей, описывает их рецепты;
- В рецепте всегда есть секретный ингредиент;
- Пользователь видеть свои коктейли и коктейли других пользователей.
- Пользователь может лайкать любые рецепты, видеть число лайков.
- При создании коктейля на фронтенде генерируется картинка, которая заливается в сервис и видна как превью коктейля в списке рецептов;
- На превью у каждой команды свой уникальный неизменяймый бар (по модулю обновления соли в сервисе)

## Архитектура
Все построено поверх k3s. 
Сетевые запросы, на первый взгляд, от балансера идут следующим образом:
```
[LB] -> [Nginx] -> [Gunicorn + Flask x4] -> [Minio]
            |                                 ^
            ->   ------------------------->   |
```

Если плотно изучить деплой (`helm get manifest prototype`), то станет понятно, что часть интерфейса файловой системы контейнера также натянута на minio (посредством csi-driver).  
В конечном итоге, публично из minio доступны картинки рецептов. Приватно же база еще обслуживает папку с рецептами коктейлей.

## Уязвимость
[CVE-2025-62506](https://github.com/minio/minio/security/advisories/GHSA-jjjj-jwhf-8rgr)  
Так как мы используем образ `minio/minio:latest`, то он, на момент выпуска сервиса в игру, **уязвим**. Minio больше [не выпускают](https://github.com/minio/minio/issues/21647) публичных образов и [предлагают](https://github.com/minio/minio/issues/21647#issuecomment-3439134621) их собирать самим.

## Эксплуатация

Метод `/obtain_account` возвращает `X-Token`. Если декодировать base64, то мы получим список вида `['access_key:secret_key', 'salt']`. 
Извлекаем эти `access_key` и `secret_key` чтобы использовать их для запросов непосредственно в minio.
Базово, эти ключи выпущены для `service-account` с ограниченными правами. Если мы попробуем сделать запросы к minio, то мы получим только созданный бакет для картинок и его содержимое.
Если же мы создадим новый `service-account` без явно переданных в него политик, то, в соответствии с уязвимостью в `CVE`, – мы получим эскалацию привелегий до уровня администратора во вновь созданном аккаунте.
Далее нужно найти бакет, который создавался для маппинга файловой системы, и вычитать все файлы с флагами / индексы пользователей от чекера (используя данные из attack-data из чексистемы) + файлы с флагами. 

Концептуально все просто, небольшая сложность возникает на уровне написания сплоита. S3 ожидает, что запрос, пришедший к нему для авторизованных операций будет корректно подписан. В случае межсервисных взаимодействий, это не проблема. 
Но при запросах извне – мы модифицируем запрос на уровне nginx. В конечном итоге нам нужно самостоятельно изготавливать подпись для такого внутрикластерного пути `http://prototype-s3.default.svc.cluster.local:9000/`, обращаясь в то же время к внешнему `http://<serivce>:<port>/s3`.

## Как фиксить
- Заменить образ `minio/minio:latest` на `alpine/minio:RELEASE.2025-10-15T17-29-55Z` или любую другую приемлемую альтернативу;  
**либо**
- Закрыть на nginx доступы к `/admin` путям.

## Сплоит
Ищите в репозитории, в папке `/sploits/prototype`.



## Unintended 
Утечка эффективного ключа HMAC, из-за переполнения SHA256 солью – выдавался ключ для подписи токена.
