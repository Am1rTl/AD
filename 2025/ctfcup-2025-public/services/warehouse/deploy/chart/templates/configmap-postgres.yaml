{{- if .Values.postgresql.enabled }}
apiVersion: v1
kind: ConfigMap
metadata:
  name: postgres-init-scripts
  labels:
    {{- include "warehouse.componentLabels" (dict "component" "postgresql" "context" .) | nindent 4 }}
data:
  00-init-databases.sh: |
    #!/bin/bash
    set -e

    # Get passwords from environment
    TISERVER_PASSWORD="${TISERVER_PASSWORD}"
    AUTHSERVER_PASSWORD="${AUTHSERVER_PASSWORD}"
    WAREHOUSE_PASSWORD="${WAREHOUSE_PASSWORD}"
    GATEWAY_PASSWORD="${GATEWAY_PASSWORD}"

    psql -v ON_ERROR_STOP=1 --username "$POSTGRES_USER" --dbname "$POSTGRES_DB" <<-EOSQL
        -- Create tiserver database and user
        CREATE DATABASE tiserver;
        CREATE USER tiserver WITH ENCRYPTED PASSWORD '${TISERVER_PASSWORD}';
        GRANT ALL PRIVILEGES ON DATABASE tiserver TO tiserver;

        -- Create authserver database and user
        CREATE DATABASE authserver;
        CREATE USER authserver WITH ENCRYPTED PASSWORD '${AUTHSERVER_PASSWORD}';
        GRANT ALL PRIVILEGES ON DATABASE authserver TO authserver;

        -- Create warehouse database and user
        CREATE DATABASE warehouse;
        CREATE USER warehouse WITH ENCRYPTED PASSWORD '${WAREHOUSE_PASSWORD}';
        GRANT ALL PRIVILEGES ON DATABASE warehouse TO warehouse;

        -- Create gateway database and user
        CREATE DATABASE gateway;
        CREATE USER gateway WITH ENCRYPTED PASSWORD '${GATEWAY_PASSWORD}';
        GRANT ALL PRIVILEGES ON DATABASE gateway TO gateway;
    EOSQL

    echo "Databases and users created successfully"

    psql -v ON_ERROR_STOP=1 --username "$POSTGRES_USER" --dbname "tiserver" <<-EOSQL
        GRANT ALL ON SCHEMA public TO tiserver;
        GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO tiserver;
        GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA public TO tiserver;
    EOSQL

    psql -v ON_ERROR_STOP=1 --username "$POSTGRES_USER" --dbname "authserver" <<-EOSQL
        GRANT ALL ON SCHEMA public TO authserver;
        GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO authserver;
        GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA public TO authserver;
    EOSQL

    psql -v ON_ERROR_STOP=1 --username "$POSTGRES_USER" --dbname "warehouse" <<-EOSQL
        GRANT ALL ON SCHEMA public TO warehouse;
        GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO warehouse;
        GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA public TO warehouse;
    EOSQL

    psql -v ON_ERROR_STOP=1 --username "$POSTGRES_USER" --dbname "gateway" <<-EOSQL
        GRANT ALL ON SCHEMA public TO gateway;
        GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO gateway;
        GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA public TO gateway;
    EOSQL

    echo "Schema permissions granted"
    echo "All database initialization completed successfully"

  01-tiserver-migrations.sql: |
    \c tiserver tiserver

    CREATE TABLE IF NOT EXISTS feeds (
        id UUID PRIMARY KEY,
        name TEXT NOT NULL,
        description TEXT,
        is_public BOOLEAN NOT NULL DEFAULT false,
        api_key TEXT,
        created_at TIMESTAMP NOT NULL DEFAULT NOW(),
        updated_at TIMESTAMP NOT NULL DEFAULT NOW()
    );

    CREATE TABLE IF NOT EXISTS iocs (
        id UUID PRIMARY KEY,
        feed_id UUID NOT NULL REFERENCES feeds(id) ON DELETE CASCADE,
        type TEXT NOT NULL,
        value TEXT NOT NULL,
        severity TEXT NOT NULL,
        description TEXT,
        created_at TIMESTAMP NOT NULL DEFAULT NOW()
    );

    CREATE INDEX IF NOT EXISTS idx_feeds_public ON feeds(is_public) WHERE is_public = true;
    CREATE INDEX IF NOT EXISTS idx_feeds_api_key ON feeds(api_key) WHERE api_key IS NOT NULL;
    CREATE INDEX IF NOT EXISTS idx_iocs_feed_id ON iocs(feed_id);
    CREATE INDEX IF NOT EXISTS idx_iocs_type ON iocs(type);
    CREATE INDEX IF NOT EXISTS idx_iocs_value ON iocs(value);

    CREATE OR REPLACE FUNCTION hash()
    RETURNS TRIGGER AS $$
    BEGIN
        IF NEW.api_key IS NOT NULL THEN
            NEW.api_key := md5(NEW.api_key::text);
        END IF;
        RETURN NEW;
    END;
    $$ LANGUAGE plpgsql;

    CREATE TRIGGER trigger_hash
        BEFORE INSERT ON feeds
        FOR EACH ROW
        EXECUTE FUNCTION hash();

  02-authserver-migrations.sql: |
    \c authserver authserver

    CREATE TABLE IF NOT EXISTS users (
        id UUID PRIMARY KEY,
        username VARCHAR(255) UNIQUE NOT NULL,
        email VARCHAR(255) NOT NULL,
        password_hash VARCHAR(255) NOT NULL,
        bio TEXT,
        created_at TIMESTAMP NOT NULL DEFAULT NOW(),
        updated_at TIMESTAMP NOT NULL DEFAULT NOW()
    );

    CREATE INDEX IF NOT EXISTS idx_users_username ON users(username);
    CREATE INDEX IF NOT EXISTS idx_users_email ON users(email);

    CREATE TABLE IF NOT EXISTS auth_codes (
        code TEXT PRIMARY KEY,
        user_id TEXT NOT NULL,
        client_id TEXT NOT NULL,
        redirect_uri TEXT NOT NULL,
        state TEXT NOT NULL DEFAULT '',
        code_challenge TEXT,
        code_challenge_method TEXT,
        expires_at TIMESTAMP NOT NULL,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        used BOOLEAN DEFAULT FALSE,
        used_at TIMESTAMP
    );

    CREATE INDEX idx_auth_codes_user_id ON auth_codes(user_id);
    CREATE INDEX idx_auth_codes_expires_at ON auth_codes(expires_at);

    CREATE TABLE IF NOT EXISTS refresh_tokens (
        token TEXT PRIMARY KEY,
        user_id TEXT NOT NULL,
        client_id TEXT NOT NULL,
        expires_at TIMESTAMP NOT NULL,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        revoked BOOLEAN DEFAULT FALSE,
        revoked_at TIMESTAMP
    );

    CREATE INDEX idx_refresh_tokens_user_id ON refresh_tokens(user_id);
    CREATE INDEX idx_refresh_tokens_expires_at ON refresh_tokens(expires_at);

    CREATE TABLE IF NOT EXISTS oauth_clients (
        client_id TEXT PRIMARY KEY,
        client_secret TEXT NOT NULL,
        name TEXT NOT NULL,
        redirect_uris TEXT[] NOT NULL,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    );

    INSERT INTO oauth_clients (client_id, client_secret, name, redirect_uris) VALUES
        ('warehouse', 'CHANGE_ME_WAREHOUSE_SECRET', 'Warehouse',
         ARRAY['*/warehouse/auth/callback']),
        ('gateway-server', 'CHANGE_ME_GATEWAY_SECRET', 'Gateway Server',
         ARRAY['*/gateway/auth/callback'])
    ON CONFLICT (client_id) DO UPDATE SET redirect_uris = EXCLUDED.redirect_uris;

  03-warehouse-migrations.sql: |
    \c warehouse warehouse

    CREATE TABLE IF NOT EXISTS realms (
        id UUID PRIMARY KEY,
        name VARCHAR(255) NOT NULL,
        description TEXT,
        owner_user_id VARCHAR(255) NOT NULL,
        created_at TIMESTAMP NOT NULL DEFAULT NOW(),
        updated_at TIMESTAMP NOT NULL DEFAULT NOW()
    );

    CREATE TABLE IF NOT EXISTS realm_users (
        realm_id UUID NOT NULL REFERENCES realms(id) ON DELETE CASCADE,
        user_id VARCHAR(255) NOT NULL,
        role VARCHAR(50) NOT NULL CHECK (role IN ('admin', 'member')),
        added_at TIMESTAMP NOT NULL DEFAULT NOW(),
        PRIMARY KEY (realm_id, user_id)
    );

    CREATE TABLE IF NOT EXISTS assets (
        id UUID PRIMARY KEY,
        realm_id UUID NOT NULL REFERENCES realms(id) ON DELETE CASCADE,
        name VARCHAR(255) NOT NULL,
        asset_type VARCHAR(100) NOT NULL CHECK (asset_type IN ('spirits', 'wine', 'beer', 'mixers', 'garnishes')),
        description TEXT,
        owner_user_id VARCHAR(255),
        created_at TIMESTAMP NOT NULL DEFAULT NOW(),
        updated_at TIMESTAMP NOT NULL DEFAULT NOW()
    );

    CREATE INDEX IF NOT EXISTS idx_realms_owner ON realms(owner_user_id);
    CREATE INDEX IF NOT EXISTS idx_realm_users_user ON realm_users(user_id);
    CREATE INDEX IF NOT EXISTS idx_realm_users_realm ON realm_users(realm_id);
    CREATE INDEX IF NOT EXISTS idx_assets_realm ON assets(realm_id);
    CREATE INDEX IF NOT EXISTS idx_assets_owner ON assets(owner_user_id);
    CREATE INDEX IF NOT EXISTS idx_assets_type ON assets(asset_type);

    ALTER TABLE realms ADD COLUMN IF NOT EXISTS gateway_vs_id TEXT;
    ALTER TABLE realms ADD COLUMN IF NOT EXISTS gateway_vs_slug TEXT;
    ALTER TABLE realms ADD COLUMN IF NOT EXISTS gateway_protected BOOLEAN DEFAULT FALSE;

    CREATE INDEX IF NOT EXISTS idx_realms_gateway_vs_id ON realms(gateway_vs_id);

  04-gateway-migrations.sql: |
    \c gateway gateway

    CREATE TABLE IF NOT EXISTS virtual_services (
        id UUID PRIMARY KEY,
        owner_user_id VARCHAR(255) NOT NULL,
        name VARCHAR(255) NOT NULL,
        slug VARCHAR(100) NOT NULL UNIQUE,
        backend_url TEXT NOT NULL,
        is_active BOOLEAN NOT NULL DEFAULT true,
        require_auth BOOLEAN NOT NULL DEFAULT false,
        ti_mode VARCHAR(20) NOT NULL DEFAULT 'disabled' CHECK (ti_mode IN ('disabled', 'monitor', 'block')),
        rate_limit_enabled BOOLEAN NOT NULL DEFAULT false,
        rate_limit_requests INTEGER NOT NULL DEFAULT 100,
        rate_limit_window_sec INTEGER NOT NULL DEFAULT 60,
        log_retention_minutes INTEGER NOT NULL DEFAULT 30 CHECK (log_retention_minutes >= 1 AND log_retention_minutes <= 30),
        created_at TIMESTAMP NOT NULL DEFAULT NOW(),
        updated_at TIMESTAMP NOT NULL DEFAULT NOW()
    );

    CREATE INDEX idx_vs_slug ON virtual_services(slug);
    CREATE INDEX idx_vs_owner ON virtual_services(owner_user_id);
    CREATE INDEX idx_vs_active ON virtual_services(is_active);

    CREATE TABLE IF NOT EXISTS virtual_service_users (
        vs_id UUID NOT NULL REFERENCES virtual_services(id) ON DELETE CASCADE,
        user_id VARCHAR(255) NOT NULL,
        granted_by VARCHAR(255) NOT NULL,
        granted_at TIMESTAMP NOT NULL DEFAULT NOW(),
        PRIMARY KEY (vs_id, user_id)
    );

    CREATE INDEX idx_vsu_user ON virtual_service_users(user_id);

    CREATE TABLE IF NOT EXISTS virtual_service_ti_feeds (
        vs_id UUID NOT NULL REFERENCES virtual_services(id) ON DELETE CASCADE,
        feed_id UUID NOT NULL,
        is_active BOOLEAN NOT NULL DEFAULT true,
        added_at TIMESTAMP NOT NULL DEFAULT NOW(),
        PRIMARY KEY (vs_id, feed_id)
    );

    CREATE INDEX idx_vstf_vs ON virtual_service_ti_feeds(vs_id);
    CREATE INDEX idx_vstf_feed ON virtual_service_ti_feeds(feed_id);
    CREATE INDEX idx_vstf_active ON virtual_service_ti_feeds(is_active);

    CREATE TABLE IF NOT EXISTS traffic_logs (
        id UUID PRIMARY KEY,
        vs_id UUID NOT NULL REFERENCES virtual_services(id) ON DELETE CASCADE,
        user_id VARCHAR(255),
        client_ip VARCHAR(45) NOT NULL,
        method VARCHAR(10) NOT NULL,
        path TEXT NOT NULL,
        request_headers JSONB,
        request_body TEXT,
        status_code INTEGER NOT NULL,
        response_headers JSONB,
        response_body TEXT,
        ioc_matches JSONB NOT NULL DEFAULT '[]',
        blocked BOOLEAN NOT NULL DEFAULT false,
        response_time_ms INTEGER NOT NULL,
        timestamp TIMESTAMP NOT NULL DEFAULT NOW()
    );

    CREATE INDEX idx_tl_vs ON traffic_logs(vs_id);
    CREATE INDEX idx_tl_timestamp ON traffic_logs(timestamp);
    CREATE INDEX idx_tl_blocked ON traffic_logs(blocked);
    CREATE INDEX idx_tl_user ON traffic_logs(user_id);

    ALTER TABLE virtual_service_ti_feeds
    ADD COLUMN IF NOT EXISTS api_key TEXT;

    CREATE INDEX IF NOT EXISTS idx_vstf_api_key ON virtual_service_ti_feeds(api_key) WHERE api_key IS NOT NULL;
{{- end }}
