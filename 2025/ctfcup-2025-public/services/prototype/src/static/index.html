<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PROTOTYPE</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üëæ</text></svg>">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Courier New', monospace;
            overflow: hidden;
            background: #000;
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: fixed;
            top: 0;
            left: 0;
            z-index: 1;
        }
        #ui-container {
            position: fixed;
            top: 50%;
            left: 50%;
            z-index: 2000; 
            pointer-events: none;
            display: none;
            justify-content: space-between;
            align-items: center;
            gap: 1%;
            padding: 0;
            transform-origin: center center;
            will-change: transform;
        }
        #ui-container.active {
            display: flex;
        }
        .book-page {
            background: rgba(10, 10, 20, 1);
            border: none;
            border-radius: 0;
            padding: 0.5% 1.5%;
            width: 50%;
            height: 100%;
            overflow-y: auto;
            pointer-events: all;
            animation: fadeIn 0.5s ease-out;
            box-sizing: border-box;
        }
        #create-page {
            display: flex;
            flex-direction: column;
            justify-content: center;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.9); }
            to { opacity: 1; transform: scale(1); }
        }
        .book-page::-webkit-scrollbar {
            width: clamp(10px, 1.2vw, 16px);
        }
        .book-page::-webkit-scrollbar-track {
            background: #1a0033;
        }
        .book-page::-webkit-scrollbar-thumb {
            background: #0ff;
            border-radius: 10px;
        }
        h1, h2 {
            color: #0ff;
            text-align: center;
            margin: 1% 0 2% 0;
            text-shadow: 0 0 10px #0ff;
            font-size: clamp(28px, 3.5vw, 48px);
        }
        .recipe-item {
            background: rgba(255, 0, 255, 0.1);
            border: 2px solid #ff00ff;
            border-radius: 12px;
            padding: 3%;
            margin-bottom: 2%;
            transition: all 0.3s;
        }
        .recipe-item:hover {
            transform: translateX(5px);
            box-shadow: 0 0 20px rgba(255, 0, 255, 0.5);
        }
        .recipe-title {
            color: #0ff;
            font-size: clamp(20px, 2.5vw, 36px);
            font-weight: bold;
            margin-bottom: 2%;
            text-shadow: 0 0 5px #0ff;
        }
        .recipe-preview {
            width: clamp(100px, 20%, 200px);
            height: clamp(100px, 20%, 200px);
            float: right;
            margin-left: 3%;
            border-radius: 10px;
            border: 2px solid #0ff;
            object-fit: contain;
            background: rgba(0,0,0,0.5);
            padding: 1%;
        }
        .recipe-text {
            color: #ff00ff;
            font-size: clamp(14px, 1.8vw, 24px);
            line-height: 1.6;
            white-space: pre-wrap;
            margin-bottom: 2%;
        }
        .recipe-secret {
            color: #9d00ff;
            font-style: italic;
            font-size: clamp(13px, 1.6vw, 22px);
            margin-top: 2%;
            padding: 2%;
            background: rgba(157, 0, 255, 0.2);
            border-radius: 8px;
            border-left: 3px solid #9d00ff;
        }
        .recipe-likes {
            color: #00ff00;
            font-size: clamp(16px, 2vw, 28px);
            margin-top: 2%;
            display: flex;
            align-items: center;
            gap: 2%;
        }
        .like-btn {
            background: linear-gradient(135deg, #00ff00 0%, #00cc00 100%);
            color: #000;
            border: none;
            padding: 1.5% 3%;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            font-size: clamp(14px, 1.8vw, 24px);
            transition: all 0.3s;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
        }
        .like-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.8);
        }
        .like-btn:disabled {
            background: #333;
            color: #666;
            cursor: not-allowed;
            box-shadow: none;
        }
        .form-group {
            margin-bottom: 3%;
        }
        label {
            display: block;
            color: #0ff;
            font-weight: bold;
            margin-bottom: 1.5%;
            font-size: clamp(18px, 2.1vw, 30px);
            text-shadow: 0 0 5px #0ff;
        }
        input, textarea {
            width: 100%;
            padding: 2%;
            border: 2px solid #0ff;
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.7);
            color: #0ff;
            font-family: 'Courier New', monospace;
            font-size: clamp(14px, 1.8vw, 24px);
        }
        input:focus, textarea:focus {
            outline: none;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
        }
        textarea {
            min-height: 120px;
            resize: vertical;
        }
        button[type="submit"] {
            background: linear-gradient(135deg, #ff00ff 0%, #9d00ff 100%);
            color: white;
            border: none;
            padding: 3% 5%;
            border-radius: 10px;
            cursor: pointer;
            font-size: clamp(18px, 2.3vw, 32px);
            font-weight: bold;
            width: 100%;
            transition: all 0.3s;
            box-shadow: 0 0 20px rgba(255, 0, 255, 0.5);
        }
        button[type="submit"]:hover {
            transform: translateY(-2px);
            box-shadow: 0 0 30px rgba(255, 0, 255, 0.8);
        }
        .message {
            padding: 2%;
            border-radius: 8px;
            margin-top: 2%;
            display: none;
            font-weight: bold;
            font-size: clamp(12px, 1.5vw, 20px);
        }
        .error-message {
            background: rgba(255, 0, 0, 0.2);
            border: 2px solid #ff0000;
            color: #ff6666;
        }
        .success-message {
            background: rgba(0, 255, 0, 0.2);
            border: 2px solid #00ff00;
            color: #66ff66;
        }
        .empty-state {
            text-align: center;
            color: #666;
            padding: 5%;
            font-size: clamp(18px, 2.3vw, 32px);
        }
        @media (max-width: 768px) {
            .book-page {
                padding: 3%;
            }
        }
        @media (orientation: portrait) and (max-width: 768px) {
            #ui-container {
                flex-direction: column;
                gap: 1.7%;
            }
            .book-page {
                width: 100%;
                height: calc(50% - 0.85%);
            }
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <div id="ui-container">
        <div class="book-page" id="recipes-page">
            <h1>üìñ –¢–û–ü –ü–†–û–¢–û–¢–ò–ü–´</h1>
            <div id="recipes-list"></div>
        </div>
        
        <div class="book-page" id="create-page">
            <h2>‚úíÔ∏è –°–û–ó–î–ê–¢–¨ –ü–†–û–¢–û–¢–ò–ü</h2>
            <form id="create-recipe-form">
                <div class="form-group">
                    <label>–ù–∞–∑–≤–∞–Ω–∏–µ –∏ —Ä–µ—Ü–µ–ø—Ç:</label>
                    <textarea id="recipe-text" required placeholder="–ù–∞–∑–≤–∞–Ω–∏–µ –ø—Ä–æ—Ç–æ—Ç–∏–ø–∞&#10;&#10;–ò–Ω–≥—Ä–µ–¥–∏–µ–Ω—Ç—ã:&#10;- ...&#10;&#10;–ò–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏:&#10;1. ..."></textarea>
                </div>
                <div class="form-group">
                    <label>–°–µ–∫—Ä–µ—Ç–Ω—ã–π –∏–Ω–≥—Ä–µ–¥–∏–µ–Ω—Ç:</label>
                    <input type="text" id="secret-ingredient" required placeholder="–í–∞—à —É–Ω–∏–∫–∞–ª—å–Ω—ã–π —Å–µ–∫—Ä–µ—Ç...">
                </div>
                <button type="submit">üç∏ –û–ü–£–ë–õ–ò–ö–û–í–ê–¢–¨</button>
                <div class="error-message message" id="error-message"></div>
                <div class="success-message message" id="success-message"></div>
            </form>
        </div>
    </div>

    <script src="/static/three.min.js"></script>
    <script>
        let scene, camera, renderer, book, leftCover, rightCover, token = null;
        let animationPhase = 'intro';
        let recipes = [];
        let animationProgress = 0;
        let leftPageMesh, rightPageMesh;
        let leftPageTexture, rightPageTexture;
        let raycaster, mouse;
        let uiContainer;
        let saltHash = null;
        
        const CYBERPUNK_COLORS = {
            neonBlue: 0x00ffff,
            neonPink: 0xff00ff,
            neonPurple: 0x9d00ff,
            neonGreen: 0x00ff00,
            neonOrange: 0xff6600
        };
        
        // –î–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä —Å–ª—É—á–∞–π–Ω—ã—Ö —á–∏—Å–µ–ª –Ω–∞ –æ—Å–Ω–æ–≤–µ seed
        class SeededRandom {
            constructor(seed) {
                this.seed = seed;
            }
            
            next() {
                this.seed = (this.seed * 9301 + 49297) % 233280;
                return this.seed / 233280;
            }
            
            range(min, max) {
                return min + this.next() * (max - min);
            }
        }
        
        function hashStringToNumber(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                const char = str.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash;
            }
            return Math.abs(hash);
        }

        async function fetchSaltHash() {
            try {
                const response = await fetch('/salt_hash');
                const data = await response.json();
                return data.salt_hash;
            } catch (e) {
                console.error('Failed to fetch salt_hash:', e);
                return 'fallback_seed_12345'; // Fallback –Ω–∞ —Å–ª—É—á–∞–π –æ—à–∏–±–∫–∏
            }
        }
        
        async function init() {
            // –ü–æ–ª—É—á–∞–µ–º salt_hash –¥–ª—è –¥–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω–æ–π –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏
            saltHash = await fetchSaltHash();
            const seed = hashStringToNumber(saltHash);
            const rng = new SeededRandom(seed);
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050510);
            scene.fog = new THREE.Fog(0x050510, 10, 40);
            
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 8, 10);
            camera.lookAt(0, 3, 0);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.getElementById('canvas-container').appendChild(renderer.domElement);
            
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            uiContainer = document.getElementById('ui-container');
            
            const ambientLight = new THREE.AmbientLight(0x222244, 0.6);
            scene.add(ambientLight);
            
            const mainLight = new THREE.PointLight(0xffaa44, 2, 20);
            mainLight.position.set(0, 8, 5);
            mainLight.castShadow = true;
            scene.add(mainLight);
            
            const neonBlue = new THREE.PointLight(CYBERPUNK_COLORS.neonBlue, 1.5, 15);
            neonBlue.position.set(-6, 4, -3);
            scene.add(neonBlue);
            
            const neonPink = new THREE.PointLight(CYBERPUNK_COLORS.neonPink, 1.5, 15);
            neonPink.position.set(6, 4, -3);
            scene.add(neonPink);
            
            createBar();
            createBottles(rng);
            createChair(-2, 0);
            createChair(-1, 0);
            createChair(0, 0);
            createChair(1, 0);
            createChair(2, 0);
            createBook();
            drawBookPages(); // Initialize page textures
            createEnvironment();
            
            loadOrCreateToken();
            
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('click', onMouseClick);
            window.addEventListener('mousemove', onMouseMove);
            
            animate();
        }
        
        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        }
        
        function onMouseClick(event) {
            // HTML —ç–ª–µ–º–µ–Ω—Ç—ã –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—é—Ç –∫–ª–∏–∫–∏ —Å–∞–º–∏
        }
        
        function createBar() {
            const counterGeometry = new THREE.BoxGeometry(12, 1, 3);
            const counterMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x1a0a0a,
                roughness: 0.3,
                metalness: 0.7
            });
            const counter = new THREE.Mesh(counterGeometry, counterMaterial);
            counter.position.set(0, 3, -2);
            counter.castShadow = true;
            counter.receiveShadow = true;
            scene.add(counter);
            
            const neonStripGeometry = new THREE.BoxGeometry(11.5, 0.1, 0.1);
            const colors = [CYBERPUNK_COLORS.neonBlue, CYBERPUNK_COLORS.neonPink, CYBERPUNK_COLORS.neonPurple];
            colors.forEach((color, i) => {
                const material = new THREE.MeshStandardMaterial({ 
                    color: color,
                    emissive: color,
                    emissiveIntensity: 1.5
                });
                const strip = new THREE.Mesh(neonStripGeometry, material);
                strip.position.set(0, 2 + i * 0.3, -0.5);
                scene.add(strip);
            });
        }
        
        function createLabelTexture(type) {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            // –§–æ–Ω —ç—Ç–∏–∫–µ—Ç–∫–∏
            ctx.fillStyle = '#f5f5dc';
            ctx.fillRect(20, 150, 216, 200);
            
            // –†–∞–º–∫–∞
            ctx.strokeStyle = '#8B4513';
            ctx.lineWidth = 3;
            ctx.strokeRect(25, 155, 206, 190);
            
            // –¢–µ–∫—Å—Ç
            ctx.fillStyle = '#2a1810';
            ctx.font = 'bold 28px serif';
            ctx.textAlign = 'center';
            const labels = {
                'wine': 'CH√ÇTEAU\nVINO',
                'whiskey': 'WHISKEY\nSINGLE MALT',
                'vodka': 'PREMIUM\nVODKA',
                'beer': 'CRAFT\nBEER',
                'cognac': 'COGNAC\nVSOP'
            };
            const lines = (labels[type] || 'DRINK').split('\n');
            lines.forEach((line, i) => {
                ctx.fillText(line, 128, 220 + i * 40);
            });
            
            // –û—Ä–Ω–∞–º–µ–Ω—Ç
            ctx.fillStyle = '#8B4513';
            ctx.font = '16px serif';
            ctx.fillText('‚òÖ EST. 1890 ‚òÖ', 128, 310);
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            return texture;
        }
        
        function createRealisticBottle(type, color) {
            const bottleGroup = new THREE.Group();
            const glassMaterial = new THREE.MeshPhysicalMaterial({ 
                color: 0xffffff, 
                transparent: true, 
                opacity: 0.3,
                roughness: 0.05,
                metalness: 0.1,
                transmission: 0.95,
                thickness: 0.5,
                envMapIntensity: 1.5
            });
            
            // –ú–∞—Ç–µ—Ä–∏–∞–ª –¥–ª—è —è—Ä–∫–æ–π –∂–∏–¥–∫–æ—Å—Ç–∏ –≤–Ω—É—Ç—Ä–∏
            const liquidMaterial = new THREE.MeshPhysicalMaterial({ 
                color: color,
                emissive: color,
                emissiveIntensity: 0.6,
                transparent: true, 
                opacity: 0.85,
                roughness: 0.3,
                metalness: 0.2
            });
            
            const labelTexture = createLabelTexture(type);
            const labelMaterial = new THREE.MeshStandardMaterial({ 
                map: labelTexture,
                roughness: 0.8,
                metalness: 0.1
            });
            
            if (type === 'wine') {
                // –í–∏–Ω–Ω–∞—è –±—É—Ç—ã–ª–∫–∞ - –∏—Å–ø–æ–ª—å–∑—É–µ–º LatheGeometry –¥–ª—è –ø–ª–∞–≤–Ω–æ–≥–æ –ø—Ä–æ—Ñ–∏–ª—è
                const points = [];
                points.push(new THREE.Vector2(0.09, -0.4));  // –Ω–∏–∑
                points.push(new THREE.Vector2(0.135, -0.35));
                points.push(new THREE.Vector2(0.145, -0.2));
                points.push(new THREE.Vector2(0.145, 0.3));  // —Ç–µ–ª–æ
                points.push(new THREE.Vector2(0.135, 0.35)); // –ø–ª–µ—á–æ
                points.push(new THREE.Vector2(0.07, 0.45));  // –≥–æ—Ä–ª–æ
                points.push(new THREE.Vector2(0.05, 0.75));  // —É–∑–∫–æ–µ –≥–æ—Ä–ª–æ
                points.push(new THREE.Vector2(0.055, 0.78)); // –≥—É–±–∞
                
                const geometry = new THREE.LatheGeometry(points, 24);
                const bottle = new THREE.Mesh(geometry, glassMaterial);
                bottleGroup.add(bottle);
                
                // –ñ–∏–¥–∫–æ—Å—Ç—å –≤–Ω—É—Ç—Ä–∏ (80% –≤—ã—Å–æ—Ç—ã –±—É—Ç—ã–ª–∫–∏)
                const liquidPoints = [];
                liquidPoints.push(new THREE.Vector2(0.095, -0.38));
                liquidPoints.push(new THREE.Vector2(0.13, -0.33));
                liquidPoints.push(new THREE.Vector2(0.14, -0.18));
                liquidPoints.push(new THREE.Vector2(0.14, 0.2));
                liquidPoints.push(new THREE.Vector2(0, 0.2));
                const liquidGeometry = new THREE.LatheGeometry(liquidPoints, 24);
                const liquid = new THREE.Mesh(liquidGeometry, liquidMaterial);
                bottleGroup.add(liquid);
                
                // –≠—Ç–∏–∫–µ—Ç–∫–∞
                const label = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.15, 0.15, 0.25, 24, 1, true),
                    labelMaterial
                );
                label.position.y = 0.05;
                bottleGroup.add(label);
                
            } else if (type === 'whiskey') {
                // –í–∏—Å–∫–∏ - –∏—Å–ø–æ–ª—å–∑—É–µ–º –±–æ–ª–µ–µ –∏–∑—è—â–Ω—É—é —Ñ–æ—Ä–º—É —Å –≥—Ä–∞–Ω—è–º–∏
                const points = [];
                points.push(new THREE.Vector2(0.12, -0.35));
                points.push(new THREE.Vector2(0.14, -0.3));
                points.push(new THREE.Vector2(0.15, 0.2));
                points.push(new THREE.Vector2(0.14, 0.3));
                points.push(new THREE.Vector2(0.08, 0.4));
                points.push(new THREE.Vector2(0.06, 0.65));
                points.push(new THREE.Vector2(0.065, 0.68));
                
                const geometry = new THREE.LatheGeometry(points, 8);  // 8 –≥—Ä–∞–Ω–µ–π –¥–ª—è –≤–∏—Å–∫–∏
                const bottle = new THREE.Mesh(geometry, glassMaterial);
                bottleGroup.add(bottle);
                
                // –ñ–∏–¥–∫–æ—Å—Ç—å –≤–Ω—É—Ç—Ä–∏
                const liquidPoints = [];
                liquidPoints.push(new THREE.Vector2(0.125, -0.33));
                liquidPoints.push(new THREE.Vector2(0.145, -0.28));
                liquidPoints.push(new THREE.Vector2(0.145, 0.15));
                liquidPoints.push(new THREE.Vector2(0, 0.15));
                const liquidGeometry = new THREE.LatheGeometry(liquidPoints, 8);
                const liquid = new THREE.Mesh(liquidGeometry, liquidMaterial);
                bottleGroup.add(liquid);
                
                const label = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.156, 0.156, 0.28, 8, 1, true),
                    labelMaterial
                );
                label.position.y = 0;
                bottleGroup.add(label);
                
                const cap = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.075, 0.075, 0.05, 8),
                    new THREE.MeshStandardMaterial({ color: 0x0a0a0a, roughness: 0.4, metalness: 0.8 })
                );
                cap.position.y = 0.71;
                bottleGroup.add(cap);
                
            } else if (type === 'vodka') {
                // –í–æ–¥–∫–∞ - —Ç–æ–Ω–∫–∞—è —ç–ª–µ–≥–∞–Ω—Ç–Ω–∞—è –±—É—Ç—ã–ª–∫–∞
                const points = [];
                points.push(new THREE.Vector2(0.08, -0.45));
                points.push(new THREE.Vector2(0.11, -0.4));
                points.push(new THREE.Vector2(0.12, 0.25));
                points.push(new THREE.Vector2(0.11, 0.32));
                points.push(new THREE.Vector2(0.055, 0.38));
                points.push(new THREE.Vector2(0.045, 0.7));
                points.push(new THREE.Vector2(0.05, 0.73));
                
                const geometry = new THREE.LatheGeometry(points, 24);
                const bottle = new THREE.Mesh(geometry, glassMaterial);
                bottleGroup.add(bottle);
                
                // –ñ–∏–¥–∫–æ—Å—Ç—å –≤–Ω—É—Ç—Ä–∏
                const liquidPoints = [];
                liquidPoints.push(new THREE.Vector2(0.085, -0.43));
                liquidPoints.push(new THREE.Vector2(0.115, -0.38));
                liquidPoints.push(new THREE.Vector2(0.115, 0.22));
                liquidPoints.push(new THREE.Vector2(0, 0.22));
                const liquidGeometry = new THREE.LatheGeometry(liquidPoints, 24);
                const liquid = new THREE.Mesh(liquidGeometry, liquidMaterial);
                bottleGroup.add(liquid);
                
                const label = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.125, 0.125, 0.35, 24, 1, true),
                    labelMaterial
                );
                label.position.y = 0;
                bottleGroup.add(label);
                
                const cap = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.055, 0.055, 0.04, 24),
                    new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.3, metalness: 0.9 })
                );
                cap.position.y = 0.76;
                bottleGroup.add(cap);
                
            } else if (type === 'beer') {
                // –ü–∏–≤–Ω–∞—è - —Ö–∞—Ä–∞–∫—Ç–µ—Ä–Ω–∞—è —Ñ–æ—Ä–º–∞ —Å —É–∑–∫–∏–º –≥–æ—Ä–ª–æ–º
                const points = [];
                points.push(new THREE.Vector2(0.07, -0.3));
                points.push(new THREE.Vector2(0.1, -0.25));
                points.push(new THREE.Vector2(0.105, 0.15));
                points.push(new THREE.Vector2(0.095, 0.22));
                points.push(new THREE.Vector2(0.045, 0.28));
                points.push(new THREE.Vector2(0.042, 0.52));
                points.push(new THREE.Vector2(0.046, 0.54));
                
                const geometry = new THREE.LatheGeometry(points, 24);
                const bottle = new THREE.Mesh(geometry, glassMaterial);
                bottleGroup.add(bottle);
                
                // –ñ–∏–¥–∫–æ—Å—Ç—å –≤–Ω—É—Ç—Ä–∏
                const liquidPoints = [];
                liquidPoints.push(new THREE.Vector2(0.075, -0.28));
                liquidPoints.push(new THREE.Vector2(0.1, -0.23));
                liquidPoints.push(new THREE.Vector2(0.1, 0.12));
                liquidPoints.push(new THREE.Vector2(0, 0.12));
                const liquidGeometry = new THREE.LatheGeometry(liquidPoints, 24);
                const liquid = new THREE.Mesh(liquidGeometry, liquidMaterial);
                bottleGroup.add(liquid);
                
                const label = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.109, 0.109, 0.22, 24, 1, true),
                    labelMaterial
                );
                label.position.y = -0.02;
                bottleGroup.add(label);
                
                const cap = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.05, 0.05, 0.03, 24),
                    new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.6 })
                );
                cap.position.y = 0.57;
                bottleGroup.add(cap);
                
            } else if (type === 'cognac') {
                // –ö–æ–Ω—å—è–∫ - —à–∏—Ä–æ–∫–∞—è –æ–∫—Ä—É–≥–ª–∞—è —Ñ–æ—Ä–º–∞
                const points = [];
                points.push(new THREE.Vector2(0.08, -0.25));
                points.push(new THREE.Vector2(0.16, -0.2));
                points.push(new THREE.Vector2(0.18, 0));
                points.push(new THREE.Vector2(0.175, 0.18));
                points.push(new THREE.Vector2(0.15, 0.28));
                points.push(new THREE.Vector2(0.08, 0.35));
                points.push(new THREE.Vector2(0.055, 0.6));
                points.push(new THREE.Vector2(0.06, 0.63));
                
                const geometry = new THREE.LatheGeometry(points, 24);
                const bottle = new THREE.Mesh(geometry, glassMaterial);
                bottleGroup.add(bottle);
                
                // –ñ–∏–¥–∫–æ—Å—Ç—å –≤–Ω—É—Ç—Ä–∏
                const liquidPoints = [];
                liquidPoints.push(new THREE.Vector2(0.085, -0.23));
                liquidPoints.push(new THREE.Vector2(0.165, -0.18));
                liquidPoints.push(new THREE.Vector2(0.175, 0.12));
                liquidPoints.push(new THREE.Vector2(0, 0.12));
                const liquidGeometry = new THREE.LatheGeometry(liquidPoints, 24);
                const liquid = new THREE.Mesh(liquidGeometry, liquidMaterial);
                bottleGroup.add(liquid);
                
                const label = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.182, 0.182, 0.25, 24, 1, true),
                    labelMaterial
                );
                label.position.y = 0.05;
                bottleGroup.add(label);
                
                const cap = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.065, 0.065, 0.08, 24),
                    new THREE.MeshStandardMaterial({ color: 0x0a0a0a, roughness: 0.3, metalness: 0.9 })
                );
                cap.position.y = 0.68;
                bottleGroup.add(cap);
            }
            
            return bottleGroup;
        }
        
        function createBottles(rng) {
            const backWallZ = -3.5;
            const shelfHeights = [3, 4.5, 6, 7.5];
            const bottleColors = [
                CYBERPUNK_COLORS.neonBlue, CYBERPUNK_COLORS.neonPink, 
                CYBERPUNK_COLORS.neonPurple, CYBERPUNK_COLORS.neonGreen,
                CYBERPUNK_COLORS.neonOrange, 0xff0000, 0xffff00, 0x00ff88,
                0x00ffaa, 0xff3366, 0x66ffcc, 0xcc33ff
            ];
            const bottleTypes = ['wine', 'whiskey', 'vodka', 'beer', 'cognac'];
            
            shelfHeights.forEach(height => {
                const shelfGeometry = new THREE.BoxGeometry(11, 0.1, 0.8);
                const shelf = new THREE.Mesh(shelfGeometry, new THREE.MeshStandardMaterial({ 
                    color: 0x1a1a1a, roughness: 0.8, metalness: 0.5 
                }));
                shelf.position.set(0, height, backWallZ);
                scene.add(shelf);
                
                for (let i = 0; i < 10; i++) {
                    const type = bottleTypes[Math.floor(rng.next() * bottleTypes.length)];
                    const color = bottleColors[Math.floor(rng.next() * bottleColors.length)];
                    const bottleGroup = createRealisticBottle(type, color);
                    
                    // –•–∞–æ—Ç–∏—á–Ω–æ–µ —Ä–∞–∑–º–µ—â–µ–Ω–∏–µ —Å –¥–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–º–∏ —Å–º–µ—â–µ–Ω–∏—è–º–∏
                    const xOffset = (rng.next() - 0.5) * 0.25;
                    const zOffset = (rng.next() - 0.5) * 0.2;
                    const yOffset = (rng.next() - 0.5) * 0.08;
                    
                    bottleGroup.position.set(-5 + i + xOffset, height + 0.5 + yOffset, backWallZ + zOffset);
                    
                    // –î–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –ø–æ–≤–æ—Ä–æ—Ç –∏ –Ω–∞–∫–ª–æ–Ω
                    bottleGroup.rotation.y = (rng.next() - 0.5) * 0.5;
                    bottleGroup.rotation.x = (rng.next() - 0.5) * 0.15;
                    bottleGroup.rotation.z = (rng.next() - 0.5) * 0.15;
                    
                    scene.add(bottleGroup);
                }
            });
        }
        
        function createChair(x, z) {
            const stoolGroup = new THREE.Group();
            
            const seat = new THREE.Mesh(
                new THREE.CylinderGeometry(0.4, 0.35, 0.15, 16),
                new THREE.MeshStandardMaterial({ color: 0x1a0033, roughness: 0.6 })
            );
            seat.position.y = 2;
            seat.castShadow = true;
            stoolGroup.add(seat);
            
            const leg = new THREE.Mesh(
                new THREE.CylinderGeometry(0.05, 0.08, 2, 8),
                new THREE.MeshStandardMaterial({ color: 0x0a0a0a, metalness: 0.9 })
            );
            leg.position.y = 1;
            stoolGroup.add(leg);
            
            const neonRing = new THREE.Mesh(
                new THREE.TorusGeometry(0.35, 0.03, 8, 16),
                new THREE.MeshStandardMaterial({ 
                    color: CYBERPUNK_COLORS.neonPurple,
                    emissive: CYBERPUNK_COLORS.neonPurple,
                    emissiveIntensity: 1
                })
            );
            neonRing.rotation.x = Math.PI / 2;
            neonRing.position.y = 1;
            stoolGroup.add(neonRing);
            
            stoolGroup.position.set(x, 0, z);
            scene.add(stoolGroup);
        }
        
        function createBook() {
            const bookGroup = new THREE.Group();
            
            // Create canvas textures for pages
            const canvasLeft = document.createElement('canvas');
            canvasLeft.width = 512;
            canvasLeft.height = 1024;
            leftPageTexture = new THREE.CanvasTexture(canvasLeft);
            
            const canvasRight = document.createElement('canvas');
            canvasRight.width = 512;
            canvasRight.height = 1024;
            rightPageTexture = new THREE.CanvasTexture(canvasRight);
            
            const pageGeometryLeft = new THREE.PlaneGeometry(1.45, 2.3);
            const leftPageMaterial = new THREE.MeshBasicMaterial({ 
                map: leftPageTexture,
                color: 0xffffff
            });
            
            leftPageMesh = new THREE.Mesh(pageGeometryLeft, leftPageMaterial);
            leftPageMesh.position.set(-0.75, 0.05, 0);
            leftPageMesh.rotation.x = -Math.PI / 2;
            leftPageMesh.castShadow = true;
            leftPageMesh.userData.isPage = true;
            leftPageMesh.userData.pageType = 'left';
            bookGroup.add(leftPageMesh);
            
            const borderLeft = new THREE.Mesh(
                new THREE.PlaneGeometry(1.46, 2.31),
                new THREE.MeshBasicMaterial({ 
                    color: 0x00ffff,
                    transparent: true,
                    opacity: 0.8
                })
            );
            borderLeft.position.set(-0.75, 0.04, 0);
            borderLeft.rotation.x = -Math.PI / 2;
            bookGroup.add(borderLeft);
            
            const pageGeometryRight = new THREE.PlaneGeometry(1.45, 2.3);
            const rightPageMaterial = new THREE.MeshBasicMaterial({ 
                map: rightPageTexture,
                color: 0xffffff
            });
            
            rightPageMesh = new THREE.Mesh(pageGeometryRight, rightPageMaterial);
            rightPageMesh.position.set(0.75, 0.05, 0);
            rightPageMesh.rotation.x = -Math.PI / 2;
            rightPageMesh.castShadow = true;
            rightPageMesh.userData.isPage = true;
            rightPageMesh.userData.pageType = 'right';
            bookGroup.add(rightPageMesh);
            
            const borderRight = new THREE.Mesh(
                new THREE.PlaneGeometry(1.46, 2.31),
                new THREE.MeshBasicMaterial({ 
                    color: 0x00ffff,
                    transparent: true,
                    opacity: 0.8
                })
            );
            borderRight.position.set(0.75, 0.04, 0);
            borderRight.rotation.x = -Math.PI / 2;
            bookGroup.add(borderRight);
            
            const coverGeometry = new THREE.BoxGeometry(1.5, 0.1, 2.4);
            const coverMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x1a0033,
                emissive: CYBERPUNK_COLORS.neonPurple,
                emissiveIntensity: 0.3,
                roughness: 0.7
            });
            
            const coverCanvas = document.createElement('canvas');
            coverCanvas.width = 512;
            coverCanvas.height = 768;
            const coverCtx = coverCanvas.getContext('2d');
            
            coverCtx.fillStyle = '#1a0033';
            coverCtx.fillRect(0, 0, 512, 768);
            
            coverCtx.fillStyle = '#ff00ff';
            coverCtx.font = 'bold 60px Arial';
            coverCtx.textAlign = 'center';
            coverCtx.fillText('–ë–ê–†–ù–´–ô', 256, 200);
            coverCtx.fillText('–ü–†–û–¢–û-', 256, 280);
            coverCtx.fillText('–¢–ò–ü–ò–ó–ê–¢–û–†', 256, 360);
            
            coverCtx.font = '200px Arial';
            coverCtx.fillText('üëæ', 256, 550);
            
            coverCtx.strokeStyle = '#00ffff';
            coverCtx.lineWidth = 4;
            coverCtx.strokeRect(20, 20, 472, 728);
            
            const coverTexture = new THREE.CanvasTexture(coverCanvas);
            coverTexture.needsUpdate = true;
            
            const leftCoverMaterial = new THREE.MeshStandardMaterial({ 
                map: coverTexture,
                emissive: CYBERPUNK_COLORS.neonPurple,
                emissiveIntensity: 0.2,
                roughness: 0.7
            });
            
            leftCover = new THREE.Mesh(coverGeometry, leftCoverMaterial);
            leftCover.position.set(-0.75, 0.05, 0);
            leftCover.castShadow = true;
            bookGroup.add(leftCover);
            
            const textureLoader = new THREE.TextureLoader();
            textureLoader.load('/static/mysh.png', (texture) => {
                const rightCoverMaterial = new THREE.MeshStandardMaterial({ 
                    map: texture,
                    emissive: CYBERPUNK_COLORS.neonPurple,
                    emissiveIntensity: 0.2,
                    roughness: 0.7
                });
                rightCover.material = rightCoverMaterial;
            });
            
            rightCover = new THREE.Mesh(coverGeometry, coverMaterial);
            rightCover.position.set(0.75, 0.05, 0);
            rightCover.castShadow = true;
            bookGroup.add(rightCover);
            
            const glowGeometry = new THREE.BoxGeometry(3.2, 0.15, 2.6);
            const glow = new THREE.Mesh(glowGeometry, new THREE.MeshBasicMaterial({ 
                color: CYBERPUNK_COLORS.neonPurple,
                transparent: true,
                opacity: 0.2
            }));
            glow.position.y = 0.05;
            bookGroup.add(glow);
            
            bookGroup.position.set(-2, 3.55, -1.5);
            bookGroup.rotation.x = 0;
            
            book = bookGroup;
            scene.add(book);
        }
        
        function createEnvironment() {
            const floor = new THREE.Mesh(
                new THREE.PlaneGeometry(50, 50),
                new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.9 })
            );
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);
            
            const backWall = new THREE.Mesh(
                new THREE.PlaneGeometry(30, 15),
                new THREE.MeshStandardMaterial({ color: 0x0a0a0a, roughness: 0.95 })
            );
            backWall.position.set(0, 7.5, -4);
            backWall.receiveShadow = true;
            scene.add(backWall);
            
            for (let i = 0; i < 30; i++) {
                const colors = [CYBERPUNK_COLORS.neonBlue, CYBERPUNK_COLORS.neonPink, CYBERPUNK_COLORS.neonPurple];
                const particle = new THREE.Mesh(
                    new THREE.SphereGeometry(0.03, 8, 8),
                    new THREE.MeshBasicMaterial({ 
                        color: colors[Math.floor(Math.random() * colors.length)],
                        transparent: true, opacity: 0.6 
                    })
                );
                particle.position.set(
                    (Math.random() - 0.5) * 25,
                    Math.random() * 12 + 2,
                    (Math.random() - 0.5) * 25
                );
                scene.add(particle);
            }
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            if (animationPhase === 'intro') {
                animationProgress += 0.012;
                
                camera.position.y = 8 - animationProgress * 3.5;
                camera.position.z = 10 - animationProgress * 8.8;
                camera.lookAt(0, 3.5 - animationProgress * 0.7, -1);
                
                if (animationProgress >= 1) {
                    animationProgress = 0;
                    animationPhase = 'moveBook';
                    camera.position.set(0, 4.5, 1.2);
                    camera.lookAt(0, 2.8, -1);
                }
            } else if (animationPhase === 'moveBook') {
                animationProgress += 0.02;
                
                book.position.x = -2 + animationProgress * 2;
                book.position.z = -1.5 + animationProgress * 0.3;
                
                if (animationProgress >= 1) {
                    animationProgress = 0;
                    animationPhase = 'openBook';
                    book.position.set(0, 3.55, -1.2);
                }
            } else if (animationPhase === 'openBook') {
                animationProgress += 0.018;
                
                const openAngle = Math.min(animationProgress * Math.PI * 0.5, Math.PI * 0.5);
                
                leftCover.rotation.z = openAngle;
                leftCover.position.x = -0.75 - Math.sin(openAngle) * 1.2;
                leftCover.position.y = 0.05 + (1 - Math.cos(openAngle)) * 0.3;
                
                rightCover.rotation.z = -openAngle;
                rightCover.position.x = 0.75 + Math.sin(openAngle) * 1.2;
                rightCover.position.y = 0.05 + (1 - Math.cos(openAngle)) * 0.3;
                
                if (animationProgress >= 1) {
                    animationProgress = 0;
                    animationPhase = 'tiltBook';
                }
            } else if (animationPhase === 'tiltBook') {
                animationProgress += 0.025;
                
                book.position.z = -1.2 + animationProgress * 1.5;
                book.position.y = 3.55 + animationProgress * 0.3;
                book.rotation.x = animationProgress * 0.35;
                
                if (animationProgress >= 1) {
                    animationProgress = 0;
                    animationPhase = 'idle';
                    book.position.set(0, 3.85, 0.3);
                    book.rotation.x = 0.35;
                    uiContainer.classList.add('active');
                }
            } else if (animationPhase === 'idle') {
                const time = Date.now() * 0.0008;
                const levitation = Math.sin(time) * 0.02;
                book.position.y = 3.85 + levitation;
                
                if (uiContainer.classList.contains('active')) {
                    const bookRotX = book.rotation.x * (180 / Math.PI);
                    
                    const camPos = camera.position;
                    const bookPos = book.position;
                    
                    const dy = bookPos.y - camPos.y;
                    const dz = bookPos.z - camPos.z;
                    const distance = Math.sqrt(dy * dy + dz * dz);
                    const viewAngle = Math.atan2(-dy, -dz) * (180 / Math.PI);
                    
                    const finalRotX = viewAngle + bookRotX - 5;
                    
                    const fov = camera.fov * (Math.PI / 180);
                    const viewHeight = 2 * Math.tan(fov / 2) * distance;
                    const viewWidth = viewHeight * camera.aspect;
                    
                    const bookTotalWidth = 3.2;
                    const bookTotalHeight = 4.0;
                    
                    const screenWidth = (bookTotalWidth / viewWidth) * window.innerWidth;
                    const screenHeight = (bookTotalHeight / viewHeight) * window.innerHeight;
                    
                    uiContainer.style.width = `${screenWidth}px`;
                    uiContainer.style.height = `${screenHeight}px`;
                    
                    const bookScreenPos = bookPos.clone().project(camera);
                    const screenX = (bookScreenPos.x * 0.5 + 0.5) * window.innerWidth;
                    const screenY = (1 - (bookScreenPos.y * 0.5 + 0.5)) * window.innerHeight;
                    
                    const offsetX = screenX - window.innerWidth / 2;
                    const offsetY = screenY - window.innerHeight / 2;
                    
                    uiContainer.style.transform = `
                        translate(-50%, -50%)
                        translate(${offsetX}px, ${offsetY}px)
                        perspective(${window.innerHeight * 1.2}px) 
                        rotateX(${finalRotX}deg)
                        rotateZ(0deg)
                    `.replace(/\s+/g, ' ');
                }
            }
            
            renderer.render(scene, camera);
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        async function loadOrCreateToken() {
            token = localStorage.getItem('x-token');
            
            if (!token) {
                try {
                    const response = await fetch('/obtain_account');
                    token = await response.text();
                    localStorage.setItem('x-token', token);
                } catch (error) {
                    console.error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Ç–æ–∫–µ–Ω–∞:', error);
                }
            }
            
            await loadRecipes();
        }
        
        async function loadRecipes() {
            try {
                const headers = token ? { 'X-Token': token } : {};
                const response = await fetch('/recipes', { headers });
                const data = await response.json();
                recipes = data.recipes || [];
                displayRecipes();
                drawBookPages();
            } catch (error) {
                console.error('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –ø—Ä–æ—Ç–æ—Ç–∏–ø–æ–≤:', error);
            }
        }
        
        function displayRecipes() {
            const container = document.getElementById('recipes-list');
            container.innerHTML = '';
            
            if (recipes.length === 0) {
                container.innerHTML = '<div class="empty-state">–ü–æ–∫–∞ –Ω–µ—Ç –ø—Ä–æ—Ç–æ—Ç–∏–ø–æ–≤.<br>–°–æ–∑–¥–∞–π—Ç–µ –ø–µ—Ä–≤—ã–π!</div>';
                return;
            }
            
            recipes.forEach(recipe => {
                const item = document.createElement('div');
                item.className = 'recipe-item';
                
                let html = '';
                
                if (recipe.preview_url) {
                    html += `<img src="/${recipe.preview_url}" class="recipe-preview" alt="–ü—Ä–æ—Ç–æ—Ç–∏–ø">`;
                }
                
                const title = recipe.recipe_text.split('\n')[0] || '–ü—Ä–æ—Ç–æ—Ç–∏–ø';
                html += `<div class="recipe-title">${escapeHtml(title)}</div>`;
                
                const createdDate = recipe.created_at ? new Date(recipe.created_at).toLocaleString('ru-RU', {
                    year: 'numeric',
                    month: 'short',
                    day: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit'
                }) : '';
                html += `<div style="color: #0ff; font-size: clamp(12px, 1.4vw, 18px); margin-bottom: 1%;">
                    üë§ ${escapeHtml(recipe.user || '–ê–Ω–æ–Ω–∏–º')} ‚Ä¢ üìÖ ${createdDate}
                </div>`;
                
                html += `<div class="recipe-text">${escapeHtml(recipe.recipe_text)}</div>`;
                
                if (recipe.secret_ingredient) {
                    html += `<div class="recipe-secret">üîê –°–µ–∫—Ä–µ—Ç: ${escapeHtml(recipe.secret_ingredient)}</div>`;
                }
                
                const isLiked = recipe.user_liked || false;
                html += `<div class="recipe-likes">
                    ‚≠ê ${recipe.likes || 0}
                    <button class="like-btn" 
                            onclick="likeRecipe('${recipe.id}')" 
                            ${isLiked ? 'disabled' : ''}>
                        ${isLiked ? '‚úì –û—Ü–µ–Ω–µ–Ω–æ' : 'üëç –û—Ü–µ–Ω–∏—Ç—å'}
                    </button>
                </div>`;
                
                item.innerHTML = html;
                container.appendChild(item);
            });
        }
        
        function drawBookPages() {
            if (!leftPageTexture || !rightPageTexture) {
                console.warn("Book textures not initialized yet.");
                return;
            }
            
            const canvasLeft = leftPageTexture.image;
            const ctxLeft = canvasLeft.getContext('2d');
            ctxLeft.fillStyle = '#0a0a14'; // Dark background matching UI
            ctxLeft.fillRect(0, 0, canvasLeft.width, canvasLeft.height);
            leftPageTexture.needsUpdate = true;
            
            const canvasRight = rightPageTexture.image;
            const ctxRight = canvasRight.getContext('2d');
            ctxRight.fillStyle = '#0a0a14'; // Dark background matching UI
            ctxRight.fillRect(0, 0, canvasRight.width, canvasRight.height);
            rightPageTexture.needsUpdate = true;
        }
        
        async function likeRecipe(recipeId) {
            if (!token) return;
            
            try {
                const response = await fetch('/like_recipe', {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-Token': token
                    },
                    body: JSON.stringify({ recipe_id: recipeId })
                });
                
                if (response.ok) {
                    await loadRecipes();
                }
            } catch (error) {
                console.error('–û—à–∏–±–∫–∞ –æ—Ü–µ–Ω–∫–∏ –ø—Ä–æ—Ç–æ—Ç–∏–ø–∞:', error);
            }
        }
        
        
        document.getElementById('create-recipe-form').addEventListener('submit', async function(e) {
            e.preventDefault();
            
            const errorMsg = document.getElementById('error-message');
            const successMsg = document.getElementById('success-message');
            errorMsg.style.display = 'none';
            successMsg.style.display = 'none';
            
            if (!token) {
                errorMsg.textContent = '–û—à–∏–±–∫–∞: –Ω–µ—Ç —Ç–æ–∫–µ–Ω–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏';
                errorMsg.style.display = 'block';
                return;
            }
            
            const recipeText = document.getElementById('recipe-text').value;
            const secretIngredient = document.getElementById('secret-ingredient').value;
            
            try {
                const seed = hashString(recipeText + secretIngredient);
                const canvas = generateBottleImage(seed);
                const blob = await canvasToBlob(canvas);
                const file = new File([blob], 'bottle.png', { type: 'image/png' });
                
                const formData = new FormData();
                formData.append('file', file);
                
                const uploadResponse = await fetch('/upload', {
                    method: 'POST',
                    headers: { 'X-Token': token },
                    body: formData
                });
                
                if (!uploadResponse.ok) {
                    throw new Error('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è');
                }
                
                const uploadData = await uploadResponse.json();
                
                const publishResponse = await fetch('/publish_recipe', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-Token': token
                    },
                    body: JSON.stringify({
                        recipe_text: recipeText,
                        secret_ingredient: secretIngredient,
                        preview_location: uploadData.loc
                    })
                });
                
                if (!publishResponse.ok) {
                    throw new Error('–û—à–∏–±–∫–∞ –ø—É–±–ª–∏–∫–∞—Ü–∏–∏ –ø—Ä–æ—Ç–æ—Ç–∏–ø–∞');
                }
                
                successMsg.textContent = '‚úÖ –ü—Ä–æ—Ç–æ—Ç–∏–ø —É—Å–ø–µ—à–Ω–æ –æ–ø—É–±–ª–∏–∫–æ–≤–∞–Ω!';
                successMsg.style.display = 'block';
                
                document.getElementById('create-recipe-form').reset();
                
                await loadRecipes();
                
            } catch (error) {
                errorMsg.textContent = '–û—à–∏–±–∫–∞: ' + error.message;
                errorMsg.style.display = 'block';
            }
        });
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        function hashString(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                const char = str.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash;
            }
            return Math.abs(hash);
        }
        
        function generateBottleImage(seed) {
            const width = 16;
            const height = 24;
            const canvas = document.createElement('canvas');
            canvas.width = width * 4;
            canvas.height = height * 4;
            const ctx = canvas.getContext('2d');
            
            const predefinedColors = [
                [255, 50, 50], [255, 100, 100], [200, 0, 0],
                [50, 100, 255], [100, 150, 255], [0, 50, 200],
                [50, 255, 50], [100, 255, 100], [0, 200, 50],
                [255, 200, 50], [255, 150, 0], [255, 255, 100],
                [200, 50, 255], [150, 0, 200], [255, 100, 255],
                [50, 255, 255], [0, 200, 200], [100, 255, 255],
                [255, 0, 127], [127, 0, 255], [255, 127, 0],
                [0, 255, 127], [127, 255, 0], [255, 255, 0],
                [255, 0, 255], [0, 255, 255]
            ];
            
            let liquidColor;
            const rng = seed % 1000 / 1000;
            if (rng < 0.7) {
                const colorIndex = seed % predefinedColors.length;
                liquidColor = predefinedColors[colorIndex];
            } else {
                liquidColor = [
                    50 + (seed % 206),
                    50 + ((seed * 7) % 206),
                    50 + ((seed * 13) % 206)
                ];
            }
            
            const glassColor = [220, 230, 240, 0.7];
            const glassDark = [180, 190, 200, 0.78];
            const corkColor = [139, 90, 60];
            const corkDark = [100, 60, 40];
            
            const centerX = Math.floor(width / 2);
            
            for (let y = 0; y < 3; y++) {
                for (let x = centerX - 2; x < centerX + 3; x++) {
                    if (x >= 0 && x < width) {
                        const color = (x === centerX - 2 || x === centerX + 2) ? corkDark : corkColor;
                        ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                        ctx.fillRect(x * 4, y * 4, 4, 4);
                    }
                }
            }
            
            for (let y = 3; y < 7; y++) {
                for (let x = centerX - 2; x < centerX + 3; x++) {
                    if (x >= 0 && x < width) {
                        const color = (x === centerX - 2 || x === centerX + 2) ? glassDark : glassColor;
                        ctx.fillStyle = `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${color[3]})`;
                        ctx.fillRect(x * 4, y * 4, 4, 4);
                    }
                }
            }
            
            const bodyStart = 7;
            const bodyEnd = height - 3;
            const bodyWidth = Math.min(width - 2, 12);
            
            for (let y = bodyStart; y < bodyEnd; y++) {
                const halfWidth = Math.floor(bodyWidth / 2);
                for (let x = centerX - halfWidth; x <= centerX + halfWidth; x++) {
                    if (x >= 0 && x < width) {
                        let color, alpha = 1;
                        if (x === centerX - halfWidth || x === centerX + halfWidth) {
                            color = glassDark;
                            alpha = glassDark[3];
                        } else if (y > bodyStart + 2) {
                            color = liquidColor;
                        } else {
                            color = glassColor;
                            alpha = glassColor[3];
                        }
                        ctx.fillStyle = alpha < 1 ? `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${alpha})` : `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                        ctx.fillRect(x * 4, y * 4, 4, 4);
                    }
                }
            }
            
            const bottomY = height - 3;
            for (let y = bottomY; y < height; y++) {
                const halfWidth = Math.floor(bodyWidth / 2) - (y - bottomY);
                for (let x = centerX - halfWidth; x <= centerX + halfWidth; x++) {
                    if (x >= 0 && x < width && halfWidth > 0) {
                        let color, alpha = 1;
                        if (x === centerX - halfWidth || x === centerX + halfWidth) {
                            color = glassDark;
                            alpha = glassDark[3];
                        } else {
                            color = liquidColor;
                        }
                        ctx.fillStyle = alpha < 1 ? `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${alpha})` : `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                        ctx.fillRect(x * 4, y * 4, 4, 4);
                    }
                }
            }
            
            return canvas;
        }
        
        async function canvasToBlob(canvas) {
            return new Promise((resolve) => {
                canvas.toBlob(resolve, 'image/png');
            });
        }
        
        init();
    </script>
</body>
</html>
